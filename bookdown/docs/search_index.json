[["index.html", "A Guide to an Image Processing Pipeline for Classification with Machine Learning Chapter 1 Introduction 1.1 About This Book 1.2 Load Packages 1.3 Introduction 1.4 Data Pipeline Overview", " A Guide to an Image Processing Pipeline for Classification with Machine Learning Henry Sun, Biniam Garomsa, Hector Ontiveros 2022-06-24 Chapter 1 Introduction 1.1 About This Book This book was authored to serve as a basic guide for using our data pipeline to process raw images using ROI software, VIA image annotation, and a random forest machine learning model. Special thanks goes to Audrey Thellman and Weston Slaughter for their guidance and mentorship. 1.2 Load Packages library(bookdown) # Knits markdown files into a book library(reticulate) # Allows python code to be ran in an R environment 1.3 Introduction The primary target users of this software are river ecologists looking to extract data from camera traps. Freshwater systems are losing ice rapidly due to rising global temperatures. Currently, studies on river ice ecology are patchy, and more so regarding small-scale rivers. Our team’s images are from the Hubbard Brook Experimental Forest in New Hampshire. Nine camera traps in as many watersheds have collected images daily for three years (see below for an example image) from which the Hubbard Brook Ecosystem Study and the U.S. Geological Survey can extract data using our product. However, our software can be viably used for any class of field image classification. 1.4 Data Pipeline Overview The data pipeline starts with raw images and finishes with a trained machine learning model which can classify pixels into groups of attributes. Each chapter of this book will cover one step in this pipeline. Renaming image files In this step, raw images have their file names converted to contain useful information including time-series data Region of interest To avoid interference from land/soil, select a polygonal region of interest containing the desired region VIA image annotation Using VGG image annotation software, classify pixels in masked images to serve as training data for the machine learning model Machine learning model Run the images through a trained model which will predict ice and snow cover "],["rename-raw-images.html", "Chapter 2 Rename Raw Images 2.1 Copying Files 2.2 Renaming Files", " Chapter 2 Rename Raw Images Renaming images is the first key step in this data processing pipeline. For our study, field camera traps in various watersheds at Hubbard Brook Experimental Forest took one photo each day over a timespan of several years. The original file names were a nondescriptive series of numbers, following this step, they will contain information about the watershed the photo was taken at as well as timeseries image metadata. These steps were designed to process files stored in a shared Google Drive. Before renaming images contained in a local directory, modifications to the script will need to be made; however, the same general principles will still apply. 2.0.1 Mount Google Drive # This will connect to your Google Drive. It will ask you to allow access drive.mount(&#39;/content/drive&#39;, force_remount=True) When using Google Colaboratory, before performing any file operations, you must mount your personal Google Drive. Run the above code to allow access. Afterwards, make sure all file paths used in any functions are for your Google Drive specifically. To find a pathname, click the orange file icon on Google Colab’s sidebar, and then click content to navigate your Google Drive. Right-click and select copy path to copy the pathname. 2.1 Copying Files This preliminary step is used when a backup or copy of the original data is needed. It will copy all files in the source directory not present in the target directory. 2.1.1 Load Packages Before each session, first run the top 3 lines – these lines of code install the Tesseract Optical Character Recognition Engine, which allows us to later use the text_to_string function and read the timestamp from each image. Subsequently, load all required packages/libraries. apt install tesseract-ocr apt install libtesseract-dev pip install pytesseract import numpy as np import pandas as pd import re import os import shutil from google.colab import drive from glob import glob 2.1.2 Copying Files This method uses shutil’s copytree function, which blanket copies all files within a specified directory. To handle issues caused by direct copying of files versus copying of subdirectories, these are copied separate from each other within the code. if missing_files == source_file_list: # Will copy entire source folder into destination when no subfolders/files are shared between the two shutil.copytree(source, destination + &#39;/&#39; + directory_name, ignore = shutil.ignore_patterns(&#39;*.gdoc&#39;, &#39;*.gsheet&#39;, &#39;*.gslides&#39;)) #1 else: for folder in missing_files: # Will copy all missing files/subfolders not present in the destination new_dst = destination + &#39;/&#39; + folder if os.path.isfile(folder) == False: # Copies all subfolders/subdirectories shutil.copytree(source + &#39;/&#39; + folder, new_dst, ignore = shutil.ignore_patterns(&#39;*.gdoc&#39;, &#39;*.gsheet&#39;, &#39;*.gslides&#39;)) #1 missing_files.remove(folder) else: # Copies files not contained within a subdirectory shutil.copy(source + &#39;/&#39; + folder, destination) missing_files.remove(folder) print(&quot;These folders/files were not copied (ignore if list is empty): &quot;) print(missing_files) Copying any Google files, be it Google Docs, Slides, Sheets, Drawings, etc. must be done manually as these files are special and not able to be copied using shutil1. For any additional file extensions to avoid copying, specify them as arguments for shutil.ignore_patterns. 2.1.3 Main Method Finally, to copy the files, simply call copy_files within the main method. This method takes 3 arguments – the file path for the source folder, the file path for the destination folder, and a folder name for the folder created if the source and destination directories share no files. args = (&quot;/content/drive/MyDrive/Duke 2022-2023/Data+/2_Camera Trap photos/Stream Photos/On_Deck&quot;, &quot;/content/drive/MyDrive/Duke 2022-2023/Data+/2_Camera Trap photos/COPY of data for script/On_Deck&quot;, &quot;Newly_uploaded_data&quot;) copy_files(*args) 2.2 Renaming Files The renaming files script takes advantage of the Tesseract OCR Engine to extract the timestamp from the image. This string is then parsed to generate time series information. There are many complementary methods in this script; for more information, see documentation within the script itself. Be sure to allocate time for the script to run, especially on folders containing large amounts of image files2 Additionally, the pixel parameters within extract_timeStamp are designed for the images taken by the field cameras used in our study. These will have to be adjusted for images with time series information contained elsewhere. def extract_timeStamp(pic_address): &#39;&#39;&#39; Extract time Stamp from picture file. From the bottom right of each picture file, the time stamp is read as image using cv2. It is then converted to a string. text which is then checked for format and subsequently returned through match_date_format. Parameters ---------- pic_address : full source address of current picture file. Returns ------- match_date_format.group(0) : unaltered timeStamp from bottom of the photo as a string. &#39;&#39;&#39; # print(pic_address) img = cv2.imread(pic_address) #read as an image # check if the timestamp is the correct format date_pattern = &quot;\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d&quot; # eg 12-12-2020 11:59:32 loop = 1 size_extension=0 x,y,z = np.shape(img) x = (x//1000)*1000 y = (y//1000)*1000 # print(x,y,z) while loop&gt;0: ts = img[2352 - size_extension:, 2000-size_extension:, :] #(change if sizing conventions change!) text = pytesseract.image_to_string(ts) match_date_format = re.search(date_pattern,text) if match_date_format: # found timestamp, return break ts_2 = img[x - size_extension:, x-size_extension:, :] #(change if sizing conventions change!) text_2= pytesseract.image_to_string(ts_2) match_date_format = re.search(date_pattern,text_2) if match_date_format: # found timestamp, return break size_extension+=100 loop-=1 if loop ==0: # reached end of loop without finding correct timestamp print(&quot;Correct timestamp not found&quot;) else: return match_date_format.group(0) As with before, make sure Google Drive is mounted, and all relevant packages/libraries are imported. Then, update the file paths3 and run the main method (below). from glob import glob #collect all folder paths from newly uploaded data on folder folder_list = glob(&quot;/content/drive/MyDrive/2_Camera Trap photos/COPY of data for script/Newly_uploaded_data/*/&quot;, recursive = True) # collect all folder path from on deck folder folder_list.extend(glob(&quot;/content/drive/MyDrive/2_Camera Trap photos/COPY of data for script/On_Deck/*/&quot;, recursive = True)) # extract folder_name folder_list = [f[:-1] for f in folder_list] i = 0 file_df = pd.read_csv(&quot;/content/drive/MyDrive/2_Camera Trap photos/COPY of data for script/Testing destination/file_df.csv&quot;) # for each folder rename and add them to the new destination - dst for folder in folder_list: print(i,&quot;/&quot;, len(folder_list)) i+=1 # destination to save labeled images dst = &quot;/content/drive/MyDrive/2_Camera Trap photos/project_dir/labeled_image_files&quot; save_as_zip = False #will unzip if necessary folder, unzipped = unzip_src(folder) # #create new destination folder fdr_name, fdr_dst = new_folder(folder, dst) if os.path.exists(fdr_dst): print(&quot;path already exists&quot;) else: print(&quot;new path&quot;) os.mkdir(fdr_dst) print(folder) print(fdr_name) print(fdr_dst) rename_images(folder, fdr_name, fdr_dst, file_df = file_df) The script generates a pandas dataframe which contains the old filename, new filename, folder name containing the image, as well as the image status (whether or not it was renamed successfully). This dataframe is then exported to a .csv file in a user-specified destination. file_df = pd.DataFrame(file_names_list, columns = [&quot;old_name&quot;, &quot;new_name&quot;,&quot;status&quot;, &quot;note&quot;,&quot;old_folder&quot;]) file_df.to_csv(dst+&quot;/&quot;+&quot;file_df.csv&quot;) file_df.head() 2.2.1 Manual Renames While this script works for the vast majority of images, occasionally some images will fail to rename correctly. For any files where the timestamp generated a file name which does not match a valid date, the below chunk of code will identify them. # Load in created csv, returns file name and path if extracted timestamp is not in range file_df = pd.read_csv(&quot;/content/drive/MyDrive/2_Camera Trap photos/project_dir/labeled_image_files/file_df.csv&quot;) file_df = file_df[file_df[&quot;new_name&quot;].notnull()] for index, row in file_df.iterrows(): #Check month range if int(row[&quot;new_name&quot;][13:15]) &gt; 12 or int(row[&quot;new_name&quot;][13:15]) &lt; 0: print(row[&quot;new_name&quot;]+&quot; Month not in range, check name in folder :&quot;+row[&quot;old_folder&quot;]) #Check year range if int(row[&quot;new_name&quot;][9:13]) &gt; 2022 or int(row[&quot;new_name&quot;][9:13]) &lt; 2018: print(row[&quot;new_name&quot;]+&quot; Year not in range, check name in folder :&quot;+row[&quot;old_folder&quot;]) #Check day range if int(row[&quot;new_name&quot;][15:17]) &gt; 31 or int(row[&quot;new_name&quot;][15:17]) &lt; 0: print(row[&quot;new_name&quot;]+&quot; Day not in range, check name in folder :&quot;+row[&quot;old_folder&quot;]) The other common occurence is if the timestamp failed to generate altogether due to pytesseract.image_to_string failing. This is sometimes unavoidable and requires manual renaming of the file. However, this should not be a frequent occurence due to the built-in loop in extract_timeStamp. For more information, see the comments within the script and text blocks in the Jupyter Notebook.↩︎ If you are looking to reduce the script’s runtime, one method is to remove the loop within extract_timeStamp which searches multiple times for the correct timestamp if it is not found initially. However, this will increase the number of files which failed to be renamed correctly.↩︎ It may be a good idea to remove or make a note of any non-image files within the folder, as these will throw errors.↩︎ "],["selecting-region-of-interest.html", "Chapter 3 Selecting Region of Interest 3.1 RoiPoly Functionality 3.2 final name of slide_through", " Chapter 3 Selecting Region of Interest This chapter provides an overview about the Python scripts used to create a polygonal region of interest and mask for images contained in folders. Before beginning this section, ensure that all image files are properly named. 3.1 RoiPoly Functionality RoiPoly4 is the python module from which our mouse click events are handled. The functions within this script allow the user to create an ROI by drawing a polygon with mouse clicks. A point is drawn by left clicking, from which a line is bounded to, extending to the user cursor. By left-clicking again, a new point is created and the line becomes static. A new line is again shown from the last point to the user cursor. To complete a figure, the user simply right or double clicks, bounding the last selected point to the first. The polygon created within the image is the region of interest. 3.2 final name of slide_through final_name_for_script is the script used to create a region of interest and mask for images within a folder. 3.2.1 Preliminary Data Collection Information This section details the functions in this script not directly related to plotting and buttons (change description) 3.2.1.1 Import necessary packages Load in all necessary packages. In the making and testing of our script, we have found that the “Qt5Agg” backend works best for Windows system while the “MacOSX” backend works best for Apple. These backends allow us to work interactively with the python plotting library matplotlib. For more information, visit matplotlib’s official website.5 import re import matplotlib as mpl import os.path import pandas as pd from PIL import Image mpl.use(&#39;Qt5Agg&#39;) # backend import cv2 from roipoly import RoiPoly import glob2 import numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Button from collections import OrderedDict from matplotlib.path import Path as MplPath 3.2.1.2 Loading Image Folder Our script denotes the file path to a folder and stores it in a variable folder_path. Change the example path to the path of the folder for which to operate on. We then use the .glob function of the glob package to store the file path for each image into the variable image_folder. folder_path = r&quot;\\Example\\Path\\To\\Folder&quot; image_folder = glob2.glob(folder_path + &quot;/*&quot;) 3.2.1.3 ImageFile Class Within this script is a class named ImageFile, from which an object containing information from a specified filepath is to be created. class ImageFile: &quot;&quot;&quot; GET ORIGINAL FILE PATH, DATE&quot;&quot;&quot; def __init__(self, filename): self.path = filename self.image_name = filename.split(&quot;\\\\&quot;)[-1] self.date = self.get_date() self.mm, self.dd, self.yy = self.date.split(&quot;/&quot;) self.mask_id = None def get_date(self): date_pattern = &quot;\\d{8}&quot; date = re.search(date_pattern, self.path).group(0) dd, mm, yy = date[-2:], date[-4:-2],date[-8:-4] date= mm + &#39;/&#39; + dd + &#39;/&#39; + yy return date def get_water_year(self): if self.mm&gt;=&quot;10&quot; or self.mm&lt;=&quot;12&quot;: return int(self.yy[-2:]) +1 else: return int(self.yy[-2:]) def file_path(self): return self.path def read_img_orig(self): img = Image.open(self.path) img = np.asarray(img) return img def read_img_sliced(self): img = self.read_img_orig() return img[::2, ::2] 3.2.1.4 Image File Object List A list with complete information of every jpg in image_folder is appended to image_file_object_list, which is then sorted and made to a list of arrays for plotting purposes. image_file_object_list = [] for filename in image_folder: filetype = filename[-4:] if filetype.lower() != &quot;.jpg&quot;: continue curr_IF = ImageFile(filename) image_file_object_list.append(curr_IF) # sort by year, then month, then day image_file_object_list = sorted(image_file_object_list, key = lambda x:(x.yy, x.mm, x.dd)) image_file_object_list = np.array(image_file_object_list) 3.2.2 Plotting, Masking, and Button Functionality This section details the user process and functions needed for image plotting and the associated interactive buttons. 3.2.2.1 Creating First Region of Interest The first image file object in image_file_object_list is plotted, allowing the user to create the first region of interest and mask(see section 2.1 RoiPoly for instruction). 3.2.2.2 Masking 3.2.2.3 Confirm Button After creating a region of interest, the user must click confirm to proceed. explain code for comfirm 3.2.2.4 Restart Masking Button To create a new region of interest, the user must click restart masking. The user should then create their new region of interest and comfirm to proceed. explain code for restarting 3.2.2.5 Next and Previous Button 3.2.2.6 Finish Masking Button Our version of RoiPoly is derived from jdoepfert’s roipoly.py, whose module can be found on at “https://github.com/jdoepfert/roipoly.py”↩︎ Information of matplotlib backends can be found at https://matplotlib.org/stable/users/explain/backends.html↩︎ "],["classifying-image-attributes-with-via.html", "Chapter 4 Classifying Image Attributes with VIA", " Chapter 4 Classifying Image Attributes with VIA TBA "],["random-forest-image-classification.html", "Chapter 5 Random Forest Image Classification", " Chapter 5 Random Forest Image Classification Insert image of machine learning output "]]
