[["index.html", "A Guide to an Image Processing Pipeline for Classification with Machine Learning Chapter 1 Introduction 1.1 About This Book 1.2 Load Packages 1.3 Introduction 1.4 Data Pipeline Overview", " A Guide to an Image Processing Pipeline for Classification with Machine Learning Henry Sun, Biniam Garomsa, Hector Ontiveros 2022-06-28 Chapter 1 Introduction 1.1 About This Book This book was authored to serve as a basic guide for using our data pipeline to process raw images using ROI software, VIA image annotation, and a random forest machine learning model. Special thanks goes to Audrey Thellman and Weston Slaughter for their guidance and mentorship. 1.2 Load Packages library(bookdown) # Knits markdown files into a book library(reticulate) # Allows python code to be ran in an R environment 1.3 Introduction The primary target users of this software are river ecologists looking to extract data from camera traps. Freshwater systems are losing ice rapidly due to rising global temperatures. Currently, studies on river ice ecology are patchy, and more so regarding small-scale rivers. Our team’s images are from the Hubbard Brook Experimental Forest in New Hampshire. Nine camera traps in as many watersheds have collected images daily for three years (see below for an example image) from which the Hubbard Brook Ecosystem Study and the U.S. Geological Survey can extract data using our product. However, our software can be viably used for any class of field image classification. 1.4 Data Pipeline Overview The data pipeline starts with raw images and finishes with a trained machine learning model which can classify pixels into groups of attributes. Each chapter of this book will cover one step in this pipeline. Renaming image files In this step, raw images have their file names converted to contain useful information including time-series data Region of interest To avoid interference from land/soil, select a polygonal region of interest containing the desired region VIA image annotation Using VGG image annotation software, classify pixels in masked images to serve as training data for the machine learning model Machine learning model Run the images through a trained model which will predict ice and snow cover "],["rename-raw-images.html", "Chapter 2 Rename Raw Images 2.1 Copying Files 2.2 Renaming Files", " Chapter 2 Rename Raw Images Renaming images is the first key step in this data processing pipeline. For our study, field camera traps in various watersheds at Hubbard Brook Experimental Forest took one photo each day over a time span of several years. The original file names were a non-descriptive series of numbers, following this step, they will contain information about the watershed the photo was taken at as well as time-series image metadata. These steps were designed to process files stored in a shared Google Drive. Before renaming images contained in a local directory, modifications to the script will need to be made; however, the same general principles will still apply. 2.0.1 Mount Google Drive # This will connect to your Google Drive. It will ask you to allow access drive.mount(&#39;/content/drive&#39;, force_remount=True) When using Google Colaboratory, before performing any file operations, you must mount your personal Google Drive. Find the code chunk with the above code in Colab and run it to allow access. Afterwards, make sure all file paths used in any functions are for your Google Drive specifically. To find a pathname, click the orange file icon on Google Colab’s sidebar, and then click content to navigate your Google Drive. Right-click and select copy path to copy the pathname (see below). 2.1 Copying Files This preliminary step is used when a backup or copy of the original data is needed. It will copy all files in the source directory not present in the target directory. 2.1.1 Load Packages Before each session, first run the top 3 lines – these lines of code install the Tesseract Optical Character Recognition Engine, which allows us to later use the text_to_string function and read the timestamp from each image. Subsequently, load all required packages/libraries. apt install tesseract-ocr apt install libtesseract-dev pip install pytesseract import numpy as np import pandas as pd import re import os import shutil from google.colab import drive from glob import glob 2.1.2 Copying Files This method uses shutil’s copytree function, which blanket copies all files within a specified directory. To handle issues caused by direct copying of files versus copying of subdirectories, these are copied separate from each other within the code. if missing_files == source_file_list: # Will copy entire source folder into destination when no subfolders/files are shared between the two shutil.copytree(source, destination + &#39;/&#39; + directory_name, ignore = shutil.ignore_patterns(&#39;*.gdoc&#39;, &#39;*.gsheet&#39;, &#39;*.gslides&#39;)) #1 else: for folder in missing_files: # Will copy all missing files/subfolders not present in the destination new_dst = destination + &#39;/&#39; + folder if os.path.isfile(folder) == False: # Copies all subfolders/subdirectories shutil.copytree(source + &#39;/&#39; + folder, new_dst, ignore = shutil.ignore_patterns(&#39;*.gdoc&#39;, &#39;*.gsheet&#39;, &#39;*.gslides&#39;)) #1 missing_files.remove(folder) else: # Copies files not contained within a subdirectory shutil.copy(source + &#39;/&#39; + folder, destination) missing_files.remove(folder) print(&quot;These folders/files were not copied (ignore if list is empty): &quot;) print(missing_files) Copying any Google files, be it Google Docs, Slides, Sheets, Drawings, etc. must be done manually as these files are special and not able to be copied using shutil1. For any additional file extensions to avoid copying, specify them as arguments for shutil.ignore_patterns. 2.1.3 Main Method Finally, to copy the files, simply call copy_files within the main method. This method takes 3 arguments – the file path for the source folder, the file path for the destination folder, and a folder name for the folder created if the source and destination directories share no files. args = (&quot;/content/drive/MyDrive/Duke 2022-2023/Data+/2_Camera Trap photos/Stream Photos/On_Deck&quot;, &quot;/content/drive/MyDrive/Duke 2022-2023/Data+/2_Camera Trap photos/COPY of data for script/On_Deck&quot;, &quot;Newly_uploaded_data&quot;) copy_files(*args) 2.2 Renaming Files The renaming files script takes advantage of the Tesseract OCR Engine to read the time stamp on the image. This string is then parsed to generate time series information. There are many complementary methods in this script; for more information, see documentation within the script itself. Be sure to allocate time for the script to run, especially on folders containing large amounts of image files2 Additionally, the pixel parameters within extract_timeStamp are designed for the images taken by the field cameras used in our study. These will have to be manually adjusted for images with time series information contained elsewhere. def extract_timeStamp(pic_address): &#39;&#39;&#39; Extract time Stamp from picture file. From the bottom right of each picture file, the time stamp is read as image using cv2. It is then converted to a string. text which is then checked for format and subsequently returned through match_date_format. Parameters ---------- pic_address : full source address of current picture file. Returns ------- match_date_format.group(0) : unaltered timeStamp from bottom of the photo as a string. &#39;&#39;&#39; # print(pic_address) img = cv2.imread(pic_address) #read as an image # check if the timestamp is the correct format date_pattern = &quot;\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d:\\d\\d&quot; # eg 12-12-2020 11:59:32 loop = 1 size_extension=0 x,y,z = np.shape(img) x = (x//1000)*1000 y = (y//1000)*1000 # print(x,y,z) while loop&gt;0: ts = img[2352 - size_extension:, 2000-size_extension:, :] #(change if sizing conventions change!) text = pytesseract.image_to_string(ts) match_date_format = re.search(date_pattern,text) if match_date_format: # found timestamp, return break ts_2 = img[x - size_extension:, x-size_extension:, :] #(change if sizing conventions change!) text_2= pytesseract.image_to_string(ts_2) match_date_format = re.search(date_pattern,text_2) if match_date_format: # found timestamp, return break size_extension+=100 loop-=1 if loop ==0: # reached end of loop without finding correct timestamp print(&quot;Correct timestamp not found&quot;) else: return match_date_format.group(0) As with before, make sure Google Drive is mounted, and all relevant packages/libraries are imported. Then, update the file paths3 and run the main method (below). from glob import glob #collect all folder paths from newly uploaded data on folder folder_list = glob(&quot;/content/drive/MyDrive/2_Camera Trap photos/COPY of data for script/Newly_uploaded_data/*/&quot;, recursive = True) # collect all folder path from on deck folder folder_list.extend(glob(&quot;/content/drive/MyDrive/2_Camera Trap photos/COPY of data for script/On_Deck/*/&quot;, recursive = True)) # extract folder_name folder_list = [f[:-1] for f in folder_list] i = 0 file_df = pd.read_csv(&quot;/content/drive/MyDrive/2_Camera Trap photos/COPY of data for script/Testing destination/file_df.csv&quot;) # for each folder rename and add them to the new destination - dst for folder in folder_list: print(i,&quot;/&quot;, len(folder_list)) i+=1 # destination to save labeled images dst = &quot;/content/drive/MyDrive/2_Camera Trap photos/project_dir/labeled_image_files&quot; save_as_zip = False #will unzip if necessary folder, unzipped = unzip_src(folder) # #create new destination folder fdr_name, fdr_dst = new_folder(folder, dst) if os.path.exists(fdr_dst): print(&quot;path already exists&quot;) else: print(&quot;new path&quot;) os.mkdir(fdr_dst) print(folder) print(fdr_name) print(fdr_dst) rename_images(folder, fdr_name, fdr_dst, file_df = file_df) The script generates a pandas dataframe which contains the old filename, new filename, folder name containing the image, as well as the image status (whether or not it was renamed successfully). This dataframe is then exported to a .csv file in a user-specified destination. See below for an example. file_df = pd.DataFrame(file_names_list, columns = [&quot;old_name&quot;, &quot;new_name&quot;,&quot;status&quot;, &quot;note&quot;,&quot;old_folder&quot;]) file_df.to_csv(dst+&quot;/&quot;+&quot;file_df.csv&quot;) file_df.head() 2.2.1 Manual Renames While this script works for the vast majority of images, occasionally some images will fail to rename correctly. For any files where the timestamp generated a file name which does not match a valid date, run the below chunk of code to identify them. # Load in created csv, returns file name and path if extracted timestamp is not in range file_df = pd.read_csv(&quot;/content/drive/MyDrive/2_Camera Trap photos/project_dir/labeled_image_files/file_df.csv&quot;) file_df = file_df[file_df[&quot;new_name&quot;].notnull()] for index, row in file_df.iterrows(): #Check month range if int(row[&quot;new_name&quot;][13:15]) &gt; 12 or int(row[&quot;new_name&quot;][13:15]) &lt; 0: print(row[&quot;new_name&quot;]+&quot; Month not in range, check name in folder :&quot;+row[&quot;old_folder&quot;]) #Check year range if int(row[&quot;new_name&quot;][9:13]) &gt; 2022 or int(row[&quot;new_name&quot;][9:13]) &lt; 2018: print(row[&quot;new_name&quot;]+&quot; Year not in range, check name in folder :&quot;+row[&quot;old_folder&quot;]) #Check day range if int(row[&quot;new_name&quot;][15:17]) &gt; 31 or int(row[&quot;new_name&quot;][15:17]) &lt; 0: print(row[&quot;new_name&quot;]+&quot; Day not in range, check name in folder :&quot;+row[&quot;old_folder&quot;]) Another common occurrence is when the timestamp failed to generate altogether due to pytesseract.image_to_string failing. This is sometimes unavoidable and requires manual renaming of the file. However, this should not be a frequent occurrence due to the built-in loop in extract_timeStamp. For more information, see the comments within the script and text blocks in the Jupyter Notebook.↩︎ If you are looking to reduce the script’s runtime, one method is to remove the loop within extract_timeStamp which searches multiple times for the correct timestamp if it is not found initially. However, this will increase the number of files which failed to be renamed correctly.↩︎ It may be a good idea to remove or make a note of any non-image files within the folder, as these will throw errors.↩︎ "],["selecting-region-of-interest.html", "Chapter 3 Selecting Region of Interest 3.1 RoiPoly Functionality 3.2 Preliminary Data Collection 3.3 First ROI and Masking Function 3.4 Masking", " Chapter 3 Selecting Region of Interest This chapter provides an overview about the Python scripts used to create a polygonal region of interest and mask for images contained in folders. Before beginning this section, ensure that all image files are properly named. interactive_ROI_app.py is the script used to create a region of interest and mask for images within a folder. 3.1 RoiPoly Functionality RoiPoly4 is the python module from which our mouse click events are handled. The functions within this script allow the user to create an ROI by drawing a polygon with mouse clicks. A point is drawn by left clicking, from which a line is bounded to, extending to the user cursor. By left-clicking again, a new point is created and the line becomes static. A new line is again shown from the last point to the user cursor. To complete a figure, the user simply right or double clicks, bounding the last selected point to the first. The polygon created within the image is the region of interest. 3.2 Preliminary Data Collection This section details the functions in this script not directly related to plotting and buttons (change description). 3.2.1 Import necessary packages Load in all necessary packages. In the making and testing of our script, we have found that the “Qt5Agg” backend works best for Windows system while the “MacOSX” backend works best for Apple. These backends allow us to work interactively with the python plotting library matplotlib. For more information, visit matplotlib’s official website.5 import re import matplotlib as mpl import os.path import pandas as pd from PIL import Image mpl.use(&#39;Qt5Agg&#39;) # backend import cv2 from roipoly import RoiPoly import glob2 import numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Button from collections import OrderedDict from matplotlib.path import Path as MplPath 3.2.2 Loading Image Folder Our script denotes the file path to a folder and stores it in a variable folder_path. Change the example path to the path of the folder for which to operate on. We then use the .glob function of the glob package to store the file path for each image into the variable image_folder. folder_path = r&quot;\\Example\\Path\\To\\Folder&quot; image_folder = glob2.glob(folder_path + &quot;/*&quot;) 3.2.3 ImageFile Class Within this script is a class named ImageFile, from which an object containing information from a specified filepath is to be created. class ImageFile: &quot;&quot;&quot; Image File class to save file path, file name, date, mask_id&quot;&quot;&quot; def __init__(self, filename): self.path = filename self.image_name = filename.split(&quot;\\\\&quot;)[-1] self.date = self.get_date() self.mm, self.dd, self.yy = self.date.split(&quot;/&quot;) self.mask_id = None def get_date(self): &quot;&quot;&quot; extracts date pattern (MM/DD/YY) from file name (eg. Hbwtr_w3_20200315_115918.JPG) :return: date &quot;&quot;&quot; date_pattern = &quot;\\d{8}&quot; # eg 12-12-2020 date = re.search(date_pattern, self.path).group(0) dd, mm, yy = date[-2:], date[-4:-2], date[-8:-4] date = mm + &#39;/&#39; + dd + &#39;/&#39; + yy return date def get_water_year(self): &quot;&quot;&quot; extracts water year from dates &quot;&quot;&quot; if self.mm &gt;= &quot;10&quot; or self.mm &lt;= &quot;12&quot;: return int(self.yy[-2:]) + 1 return int(self.yy[-2:]) def read_img_orig(self): &quot;&quot;&quot; reads image path and returns original image(np.array) &quot;&quot;&quot; return np.asarray(Image.open(self.path)) def read_img_sliced(self): &quot;&quot;&quot; reads image path and returns sliced image(np.array) for faster display select every other row and columns and return sliced image &quot;&quot;&quot; img = self.read_img_orig() return img[::2, ::2] 3.2.4 Image File Object List A list with complete information of every jpg in image_folder is appended to image_file_list, which is then sorted and made to a list of arrays for plotting purposes. image_file_list = [] for filename in image_folder: filetype = filename[-4:] # Check if the file name ends with &quot;.JPG&quot; or &quot;.jpg&quot; if filetype.lower() != &quot;.jpg&quot;: continue curr_IF = ImageFile(filename) image_file_list.append(curr_IF) # sort by year, then month, then day image_file_list = np.array(sorted(image_file_list, key=lambda x: (x.yy, x.mm, x.dd))) 3.3 First ROI and Masking Function This section details the user process and functions needed for image plotting and the associated interactive buttons. 3.3.1 Creating First Region of Interest The first image file object in image_file_object_list is plotted, allowing the user to create the first region of interest and mask (see section 2.1 RoiPoly for instruction). 3.4 Masking Each selected point in a created polygon is stored into poly_verts, which is used to create the mask outline for the region of interest. def get_mask_poly_verts(image, poly_verts, on_original=False): &quot;&quot;&quot; :param image: np.array of image :param poly_verts: list of coordinates from ROI selection :param on_original: boolean indicating if the mask is applied to riginal or sliced image :return: image mask that can be applied to image &quot;&quot;&quot; if len(np.shape(image)) == 3: ny, nx, nz = np.shape(image) else: ny, nx = np.shape(image) # if mask is applied to original, each coordinate is multiplied by 2 if on_original: poly_verts = [(2 * x, 2 * y) for (x, y) in poly_verts] x, y = np.meshgrid(np.arange(nx), np.arange(ny)) x, y = x.flatten(), y.flatten() points = np.vstack((x, y)).T roi_path = MplPath(poly_verts) mask = roi_path.contains_points(points).reshape((ny, nx)) return mask We use boolean algebra to apply the mask onto the image, making everything outside of the region of interest black. def apply_mask(im, mask): &quot;&quot;&quot; :param im: image np.array :param mask: np.array of the same size to mask :return: return masked image &quot;&quot;&quot; im[mask != 1] = 0 return im 3.4.1 Button Events This section details instruction and function for each interactive button event. These buttons are part of matplotlib’s Button module. Creating one requires an event function, as well as button initialization as seen below for the Confirm button. confirm_ax = plt.axes([0.81, 0.05, 0.1, 0.075]) confirm_button = Button(confirm_ax, &#39;Confirm&#39;) confirm_button.on_clicked(confirm_roi) confirm_button._button = confirm_button 3.4.1.1 Confirm Button After creating a region of interest, the user must click confirm to proceed and apply the mask. The confirm_roi event allows the user to confirm the selected ROI. def confirm_roi(event): &quot;&quot;&quot; Callback event for confirm button If users select ROI and hit confirm, save the poly_verts and apply it to the rest of images Then, start showing next and previous buttons &quot;&quot;&quot; # save current mask&#39;s poly_verts starting from start_img_ind index for i in range(start_img_ind, len(image_file_list)): poly_verts_list[i] = curr_poly_verts img_display_axis.set_title(&quot;Choose next or redraw ROI for {}&quot;.format(image_file_list[start_img_ind].date)) # button to show next and prev masked images _ = show_next_prev() 3.4.1.2 Restart Masking Button To create a new region of interest, the user must click restart masking. The user should then create a new region of interest and confirm to proceed to apply the new mask. After creating a new ROI, the user has the option to confirm or to restart and draw a new ROI. The underlying dynamics of the restart_masking can be seen here. def restart_masking(event): &quot;&quot;&quot; :param event: Callback event when user restarts masking Clears plot and begin a new ROI masking session &quot;&quot;&quot; global my_roi, confirm_button, restart_masking_button, img_display, img_display_axis, start_img_ind, curr_mask, curr_poly_verts # clear plot plt.clf() # create new plot fg_2 = plt.gcf() fg_2.subplots_adjust(left=0.3, bottom=0.25) fg_2.set_size_inches(w, h, forward=True) # change the content of image on curr axis img_display_axis = plt.gca() if not callback.index_in_range(): print(&quot;OUT OF RANGE&quot;) return curr_ind = callback.index curr_obj = image_file_list[curr_ind] img_display_axis.set_title(&quot;Confirm ROI? Date: {}&quot;.format(curr_obj.get_date())) img_display = img_display_axis.imshow(curr_obj.read_img_sliced()) # display new ROI pop up my_roi = RoiPoly(color=&#39;r&#39;, close_fig=False) # wait until the user finishes selecting ROI while not my_roi.finished_clicking: plt.pause(0.01) # mask current image and display cp = curr_obj.read_img_sliced().copy() curr_mask, curr_poly_verts = my_roi.get_mask(cp) cp = apply_mask(cp, curr_mask) start_img_ind = curr_ind img_display = img_display_axis.imshow(cp) # Create a confirm mask button for new session confirm_ax = plt.axes([0.81, 0.05, 0.1, 0.075]) confirm_button = Button(confirm_ax, &#39;Confirm&#39;) confirm_button.on_clicked(confirm_roi) confirm_button._button = confirm_button # Create a restart mask button for new session restart_masking_ax = plt.axes([0.1, 0.05, 0.3, 0.075]) restart_masking_button = Button(restart_masking_ax, &quot;Restart masking&quot;) restart_masking_button.on_clicked(restart_masking) plt.draw() 3.4.1.3 Next and Previous Button The next and previous buttons allow the user to click through images in the folder with the mask overlaid. These are part of the callback function Callback, which makes sliding through a folder possible through indexing. By indexing, each image is drawn with its associated date in the figure title. def next(self, event): &quot;&quot;&quot; :param event: event callback for matplotlib button Slide to the next image in folder and display it &quot;&quot;&quot; self.index += 1 if not self.index_in_range(): print(&quot;Reached End of Folder&quot;) self.index -= 1 return im = self.get_masked_img() img_display.set_data(im) img_display_axis.set_title(&quot;Click next or draw new ROI for Date: {}&quot;.format(image_file_list[self.index].get_date())) plt.draw() def prev(self, event): &quot;&quot;&quot; :param event: event callback for matplotlib button Slide to the previous image in folder and display it &quot;&quot;&quot; self.index -= 1 if not self.index_in_range(): print(&quot;Reached Start of Folder&quot;) self.index += 1 return im = self.get_masked_img() img_display.set_data(im) img_display_axis.set_title(&quot;Click next or draw new ROI for Date: {}&quot;.format(image_file_list[self.index].get_date())) plt.draw() 3.4.1.4 Finish Masking Button Once masking has been complete, click “finish masking” to close the figure. This button event also creates the water year folders, a dataframe linking every mask_id to its associated mask, a dataframe linking date of image to mask_id, and apply’s the mask onto the full size original image. This event is slow and hefty, expect a long processing time. def finish_masking(event): &quot;&quot;&quot; :param event: Callback event for finish masking button save dataframe linking mask_id to actual mask (mask_df) create water year folders save dataframe linking date to mask_id (date_mask_df) apply masks on original images and save them in their respective water year folders close plot &quot;&quot;&quot; global poly_verts_list # collect unique poly_verts and assign mask_ids to them poly_verts_unique_list = [] mask_id = -1 for i in range(len(poly_verts_list)): if mask_id == -1 or poly_verts_list[i - 1] != poly_verts_list[i]: mask_id += 1 poly_verts_unique_list.append(poly_verts_list[i]) # assign mask_ids to all ImageFile objects image_file_list[i].mask_id = mask_id # Save a mask_df data frame with columns mask_id-&gt; actual mask(poly_verts) and save it mask_df = pd.DataFrame(list(zip(poly_verts_unique_list)), columns=[&quot;poly_verts&quot;]) mask_df.index.name = &quot;mask_id&quot; mask_df_dst = folder_path + &quot;/&quot; + &quot;mask_df.csv&quot; mask_df.to_csv(mask_df_dst) # print(mask_df.head()) # collect all information from ImageFile Objects image_file_info = pd.DataFrame( [(i.date, i.mask_id, i.path, i.get_water_year(), ind, poly_verts_list[ind]) for ind, i in enumerate(image_file_list)], columns=[&quot;Date&quot;, &quot;mask_id&quot;, &quot;file_path&quot;, &quot;WY&quot;, &quot;list_index&quot;, &quot;poly_verts&quot;]) image_file_info.set_index(&quot;WY&quot;, inplace=True) # print(image_file_info.head()) # list of water years list_wy = list(image_file_info.index.unique()) print(&quot;STARTED SAVING&quot;) print(&quot;This takes about 1 second per an image file&quot;) for water_year in list_wy: # Create folders for each water year wy_dest = folder_path + &quot;/&quot; + &quot;WY&quot; + str(water_year) if not os.path.exists(wy_dest): os.mkdir(wy_dest) # loop through index of image_file_objects and save original images with their mask df = image_file_info[image_file_info.index == water_year] # save a date_mask dataframe with columns date-&gt; mask_id -&gt; file name date_mask_df = df.reset_index()[[&quot;Date&quot;, &quot;mask_id&quot;]].set_index(&quot;Date&quot;) date_mask_df.to_csv(wy_dest + &quot;/&quot; + &quot;date_mask.csv&quot;) # mask images within a selected water_year for index, row in df.iterrows(): folder_index = row[&quot;list_index&quot;] curr_file_path = row[&quot;file_path&quot;] # save masked image to WY destination curr_obj = image_file_list[folder_index] curr_file_name = curr_obj.image_name curr_original_image = curr_obj.read_img_orig().copy() curr_original_mask = get_mask_poly_verts(curr_original_image, poly_verts_list[folder_index], on_original=True) curr_original_image = apply_mask(curr_original_image, curr_original_mask) curr_img_save_dest = wy_dest + &quot;/&quot; + curr_file_name # save curr_original_image Image.fromarray(np.array(curr_original_image)).save(curr_img_save_dest) print(&quot;FINISHED SAVING&quot;) plt.close() 3.4.2 Output The output from interactive_ROI_app.py consists of sorted wateryear folders containing masked images, a dataframe linking every mask_id to its associated mask, and a dataframe linking date of image to mask_id. 3.4.2.1 Example Wateryear Output Here is an example wateryear folder containing masked images. 3.4.2.2 Example Output for Dataframes Here is an example dataframe that stores each mask_id to its associated mask. Here is an example dataframe that stores each mask_id to its associated date. Our version of RoiPoly is derived from jdoepfert’s roipoly.py, whose module can be found on at “https://github.com/jdoepfert/roipoly.py”↩︎ Information of matplotlib backends can be found at https://matplotlib.org/stable/users/explain/backends.html↩︎ "],["classifying-image-attributes-with-via.html", "Chapter 4 Classifying Image Attributes with VIA 4.1 Creating Project 4.2 Creating Attributes 4.3 Classify Pixels", " Chapter 4 Classifying Image Attributes with VIA After completing image masking, the next step is done entirely in VGG Image Annotator. This is an HTML software found online, and the demo can be accessed here. It should look like this: 4.1 Creating Project If a project already exists, navigate to the project tab in the menu bar and click load project to load in a preexisting .json file. Otherwise, remove the demo images and upload your own images using add files. At any point during annotation, these files may be saved into a .json project using Project &gt; Save from the menu bar. 4.2 Creating Attributes To create attributes for pixel classification, navigate to the bottom left-hand side of the screen to name and assign characteristics for the attribute. In our project, the classified images outputted from VIA became the training data for the machine learning model to classify snow, ice, and leaf cover. Our project used 12 different attributes, including ice_t (transparent ice), leaf_green, leaf_fall, open_water, and snow_o (opaque snow), among others. To load the attributes that we used in our project, clicking this link will open a text file. Copy the contents of this file and save it as a .json file. Then, select load project from the menu bar, and upload the .json file. 4.3 Classify Pixels Classify pixels by dragging and clicking on the image to create boxes or shapes using the desired region shape, and then assigning them to attributes. Repeat this process for all images in the folder, and export your annotations as a .json or .csv file. See below for an example using VIA’s demo file. If you must stop midway, save your project by clicking on the Settings pane in the menu bar and following the instructions. This will allow you to load in your previously saved progress directly in the future. "],["random-forest-image-classification.html", "Chapter 5 Random Forest Image Classification", " Chapter 5 Random Forest Image Classification The last step in the data pipeline is to run a random forest model to classify images. Below are some outputs generated by the model, indicating a high degree of accuracy in identifying leaf cover. The image on the right is the original masked image, whereas the image on the left is the ML output showing water in teal and leaves in gold. "]]
